<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>自動マスク世界地図</title>
  <style>
    html, body { margin: 0; overflow: hidden; background: #87CEFA; }
    canvas { display: block; cursor: grab; }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const mapImg = new Image();
mapImg.crossOrigin = "anonymous";
mapImg.src = "https://kyouyuuno-to.f5.si/img/0001.png";

let scale = 1, offsetX = 0, offsetY = 0;
let dragging = false, dragStart = { x: 0, y: 0 };
let maskMap = {}; // colorKey => true（赤塗り対象）
let regionColors = {}; // x,y => regionKey
let maskImageData;

mapImg.onload = () => {
  const w = mapImg.width, h = mapImg.height;
  const maskCanvas = document.createElement('canvas');
  maskCanvas.width = w; maskCanvas.height = h;
  const maskCtx = maskCanvas.getContext('2d');
  maskCtx.drawImage(mapImg, 0, 0);
  const data = maskCtx.getImageData(0, 0, w, h);
  maskImageData = data;

  const visited = new Uint8Array(w * h);
  const dirs = [1, -1, w, -w];
  let regionId = 1;

  const pickColor = i => [ (i*53)%256, (i*97)%256, (i*211)%256 ];

  for (let i = 0; i < w * h; i++) {
    if (visited[i]) continue;
    const idx = i * 4;
    if (data.data[idx] === 255 && data.data[idx+1] === 255 && data.data[idx+2] === 255) {
      // 白領域なら塗り始める
      const regionKey = pickColor(regionId).join(",");
      regionId++;

      const stack = [i];
      while (stack.length) {
        const pos = stack.pop();
        if (visited[pos]) continue;
        visited[pos] = 1;
        const pi = pos * 4;
        const x = pos % w, y = Math.floor(pos / w);
        regionColors[`${x},${y}`] = regionKey;

        for (let d of dirs) {
          const ni = pos + d;
          if (ni < 0 || ni >= w * h) continue;
          const ni4 = ni * 4;
          if (!visited[ni] &&
              data.data[ni4] === 255 &&
              data.data[ni4+1] === 255 &&
              data.data[ni4+2] === 255) {
            stack.push(ni);
          }
        }
      }
    } else {
      visited[i] = 1;
    }
  }

  draw();
};

function draw() {
  ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);
  ctx.clearRect(-offsetX / scale, -offsetY / scale, canvas.width / scale, canvas.height / scale);
  ctx.drawImage(mapImg, 0, 0);

  const w = mapImg.width, h = mapImg.height;
  const redOverlay = ctx.createImageData(w, h);
  for (let key in regionColors) {
    const [x, y] = key.split(',').map(Number);
    const regionKey = regionColors[key];
    if (!maskMap[regionKey]) continue;
    const i = (y * w + x) * 4;
    redOverlay.data[i] = 255;
    redOverlay.data[i+1] = 0;
    redOverlay.data[i+2] = 0;
    redOverlay.data[i+3] = 128;
  }
  ctx.putImageData(redOverlay, 0, 0);
}

// クリック処理
canvas.addEventListener('click', (e) => {
  const x = Math.floor((e.offsetX - offsetX) / scale);
  const y = Math.floor((e.offsetY - offsetY) / scale);
  const key = `${x},${y}`;
  const regionKey = regionColors[key];
  if (!regionKey) return;

  maskMap[regionKey] = !maskMap[regionKey];
  draw();
});

// ズーム
canvas.addEventListener('wheel', e => {
  e.preventDefault();
  const zoom = e.deltaY < 0 ? 1.1 : 0.9;
  const mx = e.offsetX, my = e.offsetY;
  offsetX = mx - (mx - offsetX) * zoom;
  offsetY = my - (my - offsetY) * zoom;
  scale *= zoom;
  draw();
});

// パン
canvas.addEventListener('mousedown', e => {
  dragging = true;
  dragStart = { x: e.clientX, y: e.clientY };
  canvas.style.cursor = 'grabbing';
});
canvas.addEventListener('mousemove', e => {
  if (!dragging) return;
  offsetX += e.clientX - dragStart.x;
  offsetY += e.clientY - dragStart.y;
  dragStart = { x: e.clientX, y: e.clientY };
  draw();
});
canvas.addEventListener('mouseup', () => {
  dragging = false;
  canvas.style.cursor = 'grab';
});
canvas.addEventListener('mouseleave', () => {
  dragging = false;
  canvas.style.cursor = 'grab';
});
window.addEventListener('resize', () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  draw();
});
</script>
</body>
</html>
