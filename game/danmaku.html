<!-- 完全修正済み：MiniGame🎮️PARK 弾幕ゲーム -->
<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>MiniGame🎮️PARK</title>
<style>
  body { margin:0; overflow:hidden; background:#000; color:#fff; font-family:sans-serif }
  canvas { display:block; margin:0 auto; background:#111; box-shadow:0 0 20px cyan }
  #ui {
    position:absolute; top:10px; left:50%; transform:translateX(-50%);
    display:flex; gap:20px;
  }
  .bar { width:150px; height:8px; background:#444; border:1px solid #fff }
  .bar-inner { height:100%; background:lime }
  #nextBtn {
    display:none; margin-top:5px; padding:5px 10px;
    background:cyan; border:none; cursor:pointer;
  }
  #logoScreen {
    position:absolute; top:0; left:0; right:0; bottom:0;
    background:#000; color:#0ff; font-size:32px; display:flex;
    justify-content:center; align-items:center; z-index:10;
    font-family:'Arial Black',sans-serif;
  }
</style>
</head>
<body>
<div id="logoScreen">🎮 MiniGame🎮️PARK 🎮</div>
<canvas id="gameCanvas" width="480" height="640"></canvas>
<div id="ui">
  <div>自機HP:<div id="pHP" class="bar"><div id="pHPi" class="bar-inner"></div></div></div>
  <div>敵HP:<div id="eHP" class="bar"><div id="eHPi" class="bar-inner"></div></div></div>
  <div>Stage: <span id="stageNum">1</span>/5</div>
  <div>Time: <span id="timer">00:00</span></div>
</div>
<div style="text-align:center; margin-top:10px">
  <button id="nextBtn">次のステージへ</button>
</div>

<script>
const canvas = document.getElementById("gameCanvas"), ctx = canvas.getContext("2d");
const pHPi = document.getElementById("pHPi"), eHPi = document.getElementById("eHPi");
const stageNum = document.getElementById("stageNum"), timerEl = document.getElementById("timer");
const nextBtn = document.getElementById("nextBtn"), logo = document.getElementById("logoScreen");

let startTime = Date.now();
const keys = {}; document.onkeydown = e => keys[e.key] = true;
document.onkeyup = e => keys[e.key] = false;

const player = {x:240, y:580, size:8, speed:4, hp:100, maxHP:100};
const shots = [], enemyShots = [];

const stages = [
  { pattern:"circle", interval:1000, speed:2, count:16, hp:50 },
  { pattern:"spiral", interval:200, speed:3.5, count:1, hp:70 },
  { pattern:"spread", interval:800, speed:3, count:8, hp:90 },
  { pattern:"homing", interval:600, speed:4, count:2, hp:110 },
  { pattern:"big", interval:1500, speed:2.5, count:1, hp:150 }
];
let stageIndex = 0, enemy = null, shotCooldown = 0, enemyDead = false;

function loadProgress(){
  const s = localStorage.getItem("shootStage");
  startTime = Date.now() - (parseInt(localStorage.getItem("shootTime")) || 0);
  if(s) stageIndex = Math.min(parseInt(s), stages.length-1);
}
function saveProgress(){
  localStorage.setItem("shootStage", stageIndex);
  localStorage.setItem("shootTime", Date.now() - startTime);
}

function spawnEnemy(){
  const st = stages[stageIndex];
  enemy = {
    x:240, y:100, size:12, hp:st.hp, maxHP:st.hp,
    pattern:st.pattern, interval:st.interval,
    speed:st.speed, count:st.count, timer:0
  };
  enemyDead = false;
  player.hp = player.maxHP;
  nextBtn.style.display = "none";
  stageNum.textContent = stageIndex+1;
}

nextBtn.onclick = () => {
  stageIndex++;
  saveProgress();
  if(stageIndex >= stages.length){
    alert("🎉 全5ステージクリア！マリオ風続編へ進もう！（今後追加）");
    localStorage.clear();
    location.reload();
  } else {
    spawnEnemy();
  }
};

function enemyFire(e){
  if(enemyDead) return;
  if(Date.now() - e.timer < e.interval) return;
  e.timer = Date.now();
  const dx = player.x - e.x, dy = player.y - e.y;
  if(e.pattern==="circle"){
    for(let i=0;i<e.count;i++){
      let ang = i*(2*Math.PI/e.count);
      enemyShots.push({x:e.x,y:e.y,vx:Math.cos(ang)*e.speed,vy:Math.sin(ang)*e.speed,size:4});
    }
  } else if(e.pattern==="spiral"){
    const ang = (Date.now()/300)% (2*Math.PI);
    enemyShots.push({x:e.x,y:e.y,vx:Math.cos(ang)*e.speed,vy:Math.sin(ang)*e.speed,size:4});
  } else if(e.pattern==="spread"){
    const base = Math.atan2(dy,dx), spr = Math.PI/8;
    for(let i=-e.count/2;i<e.count/2;i++){
      const ang = base + i*(spr/(e.count/2));
      enemyShots.push({x:e.x,y:e.y,vx:Math.cos(ang)*e.speed,vy:Math.sin(ang)*e.speed,size:4});
    }
  } else if(e.pattern==="homing"){
    const ang = Math.atan2(dy,dx);
    enemyShots.push({x:e.x,y:e.y,vx:Math.cos(ang)*e.speed,vy:Math.sin(ang)*e.speed,size:6});
  } else if(e.pattern==="big"){
    enemyShots.push({x:e.x,y:e.y,vx:0,vy:e.speed,size:16});
  }
}

function update(){
  const elapsed = Date.now() - startTime;
  timerEl.textContent = `${String(Math.floor(elapsed/60000)).padStart(2,'0')}:${String(Math.floor(elapsed/1000)%60).padStart(2,'0')}`;

  if(keys.ArrowLeft) player.x -= player.speed;
  if(keys.ArrowRight) player.x += player.speed;
  if(keys.ArrowUp) player.y -= player.speed;
  if(keys.ArrowDown) player.y += player.speed;
  player.x = Math.max(0, Math.min(canvas.width, player.x));
  player.y = Math.max(0, Math.min(canvas.height, player.y));

  if(keys[" "] && Date.now() > shotCooldown){
    shots.push({x:player.x,y:player.y,vx:0,vy:-6,size:5});
    shotCooldown = Date.now() + 200;
  }

  if(enemy && !enemyDead) enemyFire(enemy);

  [...shots, ...enemyShots].forEach(b=>{ b.x += b.vx; b.y += b.vy });

  for(let i=enemyShots.length-1; i>=0; i--){
    const b = enemyShots[i];
    if(Math.hypot(b.x - player.x, b.y - player.y) < b.size + player.size){
      player.hp -= 10;
      enemyShots.splice(i,1);
    }
  }

  for(let i=shots.length-1; i>=0; i--){
    const b = shots[i];
    if(enemy && !enemyDead && Math.hypot(b.x - enemy.x, b.y - enemy.y) < b.size + enemy.size){
      enemy.hp -= 5;
      shots.splice(i,1);
    }
  }

  pHPi.style.width = (player.hp/player.maxHP*100)+"%";
  if(enemy) eHPi.style.width = (enemy.hp/enemy.maxHP*100)+"%";

  if(enemy && enemy.hp <= 0 && !enemyDead){
    enemyDead = true;
    nextBtn.style.display = "inline-block";
  }

  if(player.hp <= 0){
    alert("ゲームオーバー！");
    localStorage.clear();
    location.reload();
  }

  [shots,enemyShots].forEach(arr=>{
    for(let i=arr.length-1;i>=0;i--){
      const b=arr[i];
      if(b.x<0||b.x>canvas.width||b.y<0||b.y>canvas.height) arr.splice(i,1);
    }
  });
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle="cyan"; ctx.beginPath();
  ctx.arc(player.x,player.y,player.size,0,2*Math.PI); ctx.fill();
  if(enemy && !enemyDead){
    ctx.fillStyle="orange"; ctx.beginPath();
    ctx.arc(enemy.x,enemy.y,enemy.size,0,2*Math.PI); ctx.fill();
  }
  shots.forEach(b=>{ ctx.fillStyle="lime"; ctx.beginPath();
    ctx.arc(b.x,b.y,b.size,0,2*Math.PI); ctx.fill(); });
  enemyShots.forEach(b=>{ ctx.fillStyle="red"; ctx.beginPath();
    ctx.arc(b.x,b.y,b.size,0,2*Math.PI); ctx.fill(); });
}

function loop(){ update(); draw(); requestAnimationFrame(loop); }

setTimeout(() => { logo.style.display = "none"; loop(); }, 2000);
</script>
</body>
</html>
