<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>境界塗り国家マップ</title>
<style>
  body { font-family: sans-serif; display: flex; }
  #mapContainer { position: relative; }
  canvas { border: 1px solid #000; cursor: crosshair; }
  #controls { margin-left: 20px; width: 300px; }
  input, button { margin: 5px 0; display: block; width: 100%; }
</style>
</head>
<body>
<div id="mapContainer">
  <canvas id="mapCanvas" width="800" height="600"></canvas>
</div>
<div id="controls">
  <h3>塗り設定</h3>
  <label>塗り色: <input type="color" id="fillColor" value="#ff0000"></label>
  <button id="saveBtn">セーブ</button>
  <button id="loadBtn">ロード</button>
  <pre id="jsonOutput"></pre>
</div>

<script>
const canvas = document.getElementById('mapCanvas');
const ctx = canvas.getContext('2d');

const mapImage = new Image();
mapImage.crossOrigin = 'anonymous';
mapImage.src = 'https://kyouyuuno-to.f5.si/img/0001.svg';
mapImage.onload = () => {
  ctx.drawImage(mapImage, 0, 0, canvas.width, canvas.height);
};

// バケツ塗り（Flood Fill）
function floodFill(x, y, fillColor) {
  const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const data = imgData.data;
  
  function colorMatch(idx, targetColor) {
    return data[idx] === targetColor[0] &&
           data[idx+1] === targetColor[1] &&
           data[idx+2] === targetColor[2];
  }
  
  function setColor(idx, newColor) {
    data[idx] = newColor[0];
    data[idx+1] = newColor[1];
    data[idx+2] = newColor[2];
  }
  
  const width = canvas.width;
  const height = canvas.height;
  const stack = [];
  const idx = (y * width + x) * 4;
  const startColor = [data[idx], data[idx+1], data[idx+2]];
  const boundaryColor = [128,128,128]; // 灰色と黒の境界は塗らない
  const boundaryColor2 = [0,0,0];
  const newColor = [
    parseInt(fillColor.slice(1,3),16),
    parseInt(fillColor.slice(3,5),16),
    parseInt(fillColor.slice(5,7),16)
  ];
  
  if( (startColor[0]===boundaryColor[0] && startColor[1]===boundaryColor[1] && startColor[2]===boundaryColor[2]) ||
      (startColor[0]===boundaryColor2[0] && startColor[1]===boundaryColor2[1] && startColor[2]===boundaryColor2[2]) ) return;

  stack.push([x,y]);
  while(stack.length){
    const [cx,cy] = stack.pop();
    const cidx = (cy*width + cx)*4;
    const cColor = [data[cidx],data[cidx+1],data[cidx+2]];
    if( (cColor[0]===boundaryColor[0] && cColor[1]===boundaryColor[1] && cColor[2]===boundaryColor[2]) ||
        (cColor[0]===boundaryColor2[0] && cColor[1]===boundaryColor2[1] && cColor[2]===boundaryColor2[2]) ) continue;
    if( cColor[0]===newColor[0] && cColor[1]===newColor[1] && cColor[2]===newColor[2] ) continue;
    
    setColor(cidx,newColor);
    
    if(cx>0) stack.push([cx-1,cy]);
    if(cx<width-1) stack.push([cx+1,cy]);
    if(cy>0) stack.push([cx,cy-1]);
    if(cy<height-1) stack.push([cx,cy+1]);
  }
  ctx.putImageData(imgData,0,0);
}

// クリックでバケツ塗り
canvas.addEventListener('click', e=>{
  const rect = canvas.getBoundingClientRect();
  const x = Math.floor(e.clientX - rect.left);
  const y = Math.floor(e.clientY - rect.top);
  const color = document.getElementById('fillColor').value;
  floodFill(x,y,color);
});

// --- JSONセーブ/ロード ---
function getMapData(){
  return canvas.toDataURL(); // 画像として保存
}

document.getElementById('saveBtn').addEventListener('click', ()=>{
  const saveData = getMapData();
  document.getElementById('jsonOutput').textContent = saveData;
  localStorage.setItem('mapSave', saveData);
});

document.getElementById('loadBtn').addEventListener('click', ()=>{
  const loadData = localStorage.getItem('mapSave');
  if(!loadData) return;
  const img = new Image();
  img.onload = ()=>ctx.drawImage(img,0,0,canvas.width,canvas.height);
  img.src = loadData;
});
</script>
</body>
</html>
