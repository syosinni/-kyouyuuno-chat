<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>国家運営ゲーム - 完全版</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    canvas {
      display: block;
      background: #f0f0f0;
      cursor: crosshair;
    }
    #toolbar {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(255,255,255,0.9);
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    }
    #toolbar button, #toolbar input {
      margin: 5px;
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <button onclick="setMode('pan')">移動</button>
    <button onclick="setMode('draw')">境界線描画</button>
    <input type="color" id="colorPicker" value="#00aaff">
    <button onclick="setMode('fill')">塗りつぶし</button>
  </div>
  <canvas id="map"></canvas>
  <script>
    const canvas = document.getElementById("map");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // ゲームモード
    let mode = "pan";
    let isDrawing = false;
    let startX, startY;
    let offsetX = 0, offsetY = 0;
    let scale = 1;

    // 線データ保存
    let lines = [];
    let currentLine = [];

    function setMode(m) {
      mode = m;
    }

    // パン移動用
    let isPanning = false;
    let panStartX, panStartY;

    canvas.addEventListener("mousedown", e => {
      const x = (e.offsetX - offsetX) / scale;
      const y = (e.offsetY - offsetY) / scale;

      if (mode === "draw") {
        isDrawing = true;
        currentLine.push([x, y]);
      } else if (mode === "pan") {
        isPanning = true;
        panStartX = e.clientX - offsetX;
        panStartY = e.clientY - offsetY;
      } else if (mode === "fill") {
        const color = document.getElementById("colorPicker").value;
        floodFill(e.offsetX, e.offsetY, hexToRgb(color));
      }
    });

    canvas.addEventListener("mousemove", e => {
      const x = (e.offsetX - offsetX) / scale;
      const y = (e.offsetY - offsetY) / scale;

      if (isDrawing) {
        currentLine.push([x, y]);
        redraw();
      } else if (isPanning) {
        offsetX = e.clientX - panStartX;
        offsetY = e.clientY - panStartY;
        redraw();
      }
    });

    canvas.addEventListener("mouseup", () => {
      if (isDrawing) {
        lines.push(currentLine);
        currentLine = [];
        isDrawing = false;
      }
      isPanning = false;
    });

    // Flood Fill (境界塗りつぶし)
    function floodFill(startX, startY, fillColor) {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;

      const targetColor = getPixel(data, startX, startY);

      if (colorsMatch(targetColor, fillColor)) return;

      const stack = [[startX, startY]];
      while (stack.length > 0) {
        const [x, y] = stack.pop();
        const currentColor = getPixel(data, x, y);

        if (colorsMatch(currentColor, targetColor)) {
          setPixel(data, x, y, fillColor);

          stack.push([x + 1, y]);
          stack.push([x - 1, y]);
          stack.push([x, y + 1]);
          stack.push([x, y - 1]);
        }
      }

      ctx.putImageData(imageData, 0, 0);
    }

    function getPixel(data, x, y) {
      const index = (y * canvas.width + x) * 4;
      return [data[index], data[index + 1], data[index + 2], data[index + 3]];
    }

    function setPixel(data, x, y, color) {
      const index = (y * canvas.width + x) * 4;
      data[index] = color[0];
      data[index + 1] = color[1];
      data[index + 2] = color[2];
      data[index + 3] = 255;
    }

    function colorsMatch(a, b) {
      return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
    }

    function hexToRgb(hex) {
      const bigint = parseInt(hex.slice(1), 16);
      return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255, 255];
    }

    // 描画更新
    function redraw() {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);

      ctx.strokeStyle = "black";
      ctx.lineWidth = 2;

      lines.forEach(line => {
        ctx.beginPath();
        ctx.moveTo(line[0][0], line[0][1]);
        for (let i = 1; i < line.length; i++) {
          ctx.lineTo(line[i][0], line[i][1]);
        }
        ctx.stroke();
      });

      if (currentLine.length > 0) {
        ctx.beginPath();
        ctx.moveTo(currentLine[0][0], currentLine[0][1]);
        for (let i = 1; i < currentLine.length; i++) {
          ctx.lineTo(currentLine[i][0], currentLine[i][1]);
        }
        ctx.stroke();
      }
    }

    redraw();
  </script>
</body>
</html>
